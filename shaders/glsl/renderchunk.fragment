// __multiversion__
// This signals the loading code to prepend either #version 100 or #version 300 es as apropriate.

#include "fragmentVersionCentroid.h"

#if __VERSION__ >= 300
	#ifndef BYPASS_PIXEL_SHADER
		#if defined(TEXEL_AA) && defined(TEXEL_AA_FEATURE)
			_centroid in highp vec2 uv0;
			_centroid in highp vec2 uv1;
		#else
			_centroid in vec2 uv0;
			_centroid in vec2 uv1;
		#endif
	#endif //BYPASS_PIXEL_SHADER
#else
	#ifndef BYPASS_PIXEL_SHADER
		varying vec2 uv0;
		varying vec2 uv1;
	#endif	//BYPASS_PIXEL_SHADER
#endif //VERSION

varying vec4 color;//TODO what is this color??
vec4 normalColor;// fake normal vector will be stored here or may be later will be passed from vertex shader
varying highp vec4 position;// get pixel position in world space (used for calculate fake normals)
varying highp vec3 relativePosition;//calculates from vec4 position
#ifdef FOG
	varying vec4 fogColor;
#endif //FOG

#include "uniformShaderConstants.h"
#include "util.h"
#include "uniformPerFrameConstants.h"
LAYOUT_BINDING(0) uniform sampler2D TEXTURE_0;
LAYOUT_BINDING(1) uniform sampler2D TEXTURE_1;
LAYOUT_BINDING(2) uniform sampler2D TEXTURE_2;

varying vec4 blueFog;
varying vec4 milkyFog;


float noise(highp vec2 coord){
	return fract(sin(dot(coord.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

float smoothNoise(vec2 o){
	vec2 a = fract(o.xy);
	vec2 b = floor(o.xy);
	
	float t = noise(b);
	float tt = noise(b + vec2(1.0, 0.0));
	float d = mix(t, tt, a.x);

	float k = noise(b + vec2(0.0, 1.0));
	float kk = noise(b + vec2(1.0, 1.0));
	float e = mix(k, kk, a.x);
	return mix(d, e, a.y);
}

void main()
{	
#ifdef BYPASS_PIXEL_SHADER
	gl_FragColor = vec4(1.0, 0, 0, 1.0);
	return;
#else 

#if USE_TEXEL_AA
	vec4 diffuse = texture2D_AA(TEXTURE_0,uv0);
#else


	////////////////////////////mapping section///////////////////////////////////

	//by default (with default texture pack) result "megatexture" demensions is 1.0 x 0.5
	//but wtih my texture pack I have 1.0 x 1.0. with your custom texuture pack you should check result texture  dimensions
	
	//top left texture - default diffuse
	highp vec2 localDiffuseCoord = fract(uv0 * vec2(32.0)) * vec2(0.015625);// 1.0 / 64.0 = 0.015625
	//top right texture - specular map
	highp vec2 localSpecularCoord = localDiffuseCoord - vec2(0.015625, 0.0);// 1.0/64.0 = 0.015625


	//debug checking result texture (you should find block with top left corner texture  and place it somewhere in the world)
	//vec4 diffuse = texture2D(TEXTURE_0, uv0 * 32.0 - vec2(0.5, 0.0));
	
	vec4 diffuse = texture2D(TEXTURE_0, uv0 - localDiffuseCoord);
	vec4 specularMap = clamp(texture2D(TEXTURE_0, uv0 - localSpecularCoord),0.01, 1.0);
	vec4 normalMap = vec4(0.0);	
	normalColor.rgb = vec3(0.0);
	bool isWater = false;

	if(color.b > color.g * 0.8 && color.b > color.r * 1.1){
		isWater = true;
		normalColor.rgb = vec3(0.0,1.0,0.0);
		highp float t = TIME * 0.25;

		// 1.0/64.0 = 0.0156251          1.5 / 32.0 =  0.046875 (water normal map offset)
		normalMap = texture2D(TEXTURE_0, fract(position.xz + t)*0.015625 + 0.046875);
		normalMap += texture2D(TEXTURE_0, fract(position.xz*0.5 - t * 0.5)*0.015625 + 0.046875);// 
		//normalMap += texture2D(TEXTURE_0, fract(position.xz*0.25 + t * 0.2)*0.015625 + 0.046875);
		//normalMap += texture2D(TEXTURE_0, fract(position.xz*0.125 - t * 0.1)*0.015625 + 0.046875);
		normalMap *= 0.5;
		//normalMap *= 0.33;
		//normalMap *= 0.25;

	}else{
		//bottom left  texture - normalmap
		highp vec2 localNormalCoord = localDiffuseCoord - vec2(0.0, 0.015625);
		normalMap = texture2D(TEXTURE_0, uv0 - localNormalCoord);

		//normalMap = texture2D(TEXTURE_0, uv0);
	}
	
#endif //USE_TEXEL_AA


//maybe it's about LOD (far trees and water becomes opaque)
#ifdef SEASONS_FAR
	diffuse.a = 1.0;
#endif //SEASONS_FAR


#if USE_ALPHA_TEST
	#ifdef ALPHA_TO_COVERAGE
	#define ALPHA_THRESHOLD 0.05
	#else
	#define ALPHA_THRESHOLD 0.5
	#endif //APLPHA_TO_COVERAGE
	if(diffuse.a < ALPHA_THRESHOLD)
		discard;//catout leaves and grass
#endif //USE_ALPHA_TEST
	

#if defined(BLEND)
	//diffuse.a *= inColor.a;
#endif //BLEND

#if !defined(ALWAYS_LI)
	//TODO try to calculate not doublesided normals
	//TODO or try to get normals from vertex shader (currently it is not available or just returns messy stuff) 
	float posMult = 1.0;
	while(length(normalColor.rgb) < 0.5 && posMult < 128.0){// decrease position fraction scale intyl normal color isn't 0
		normalColor.rgb = vec3(1.0 - ceil(fract(position.xyz * posMult)));
		posMult += posMult;
	}
	//after previous calculation normalColor for plants is black
	//todo maybe it can be used to derirmine if there is a plant;
	if(length(normalColor.rgb) < 0.5){
		normalColor.rgb = vec3(0.0,1.0,0.0);//make them green like they are locking forward		
	}

	//fake TBN transformations for normalmapps
 	if(length(normalMap.rgb) > 0.9){
		if(normalColor.g == 1.0){
			normalMap.gb = normalMap.bg;
    			normalColor.rgb = normalize(normalMap.rgb * 2.0 - 1.0);
		}else{

			if (normalColor.b == 1.0){
				normalMap.g = 1.0 - normalMap.g;//OpenGl style G flip
    				normalColor.rgb = normalize(normalMap.rgb * 2.0 - 1.0);
 
			}else{

				if(normalColor.r == 1.0){
					normalMap.g = 1.0 - normalMap.g;//OpenGl style G flip
					normalMap.rb = normalMap.br;
    					normalColor.rgb = normalize(normalMap.rgb * 2.0 - 1.0);
				}
			}
		}
	}


	const vec3 skyLightDirection  = vec3(0.0,1.0,0.0);//todo connect with time attribute
	const float skyLightWrapping = 4.0;//make sky lighting from sides too
	float skyDot = max((dot(skyLightDirection, normalColor.rgb) + skyLightWrapping)/(1.0 + skyLightWrapping),0.0);
	const vec3 skyLightColor = vec3(0.45,0.7,1.1);//todo connect with time attribute

	const vec3 sunLightDirection = vec3(0.5,0.4,0.1);//todo connect with time attribute
	float sunDot = max(dot(sunLightDirection, normalColor.rgb), 0.0);//todo use normalmaps to represent surface details	
	const vec3 sunLightColor = vec3(1.0, 0.9, 0.8);//todo connect with time attribute

	//blinn-phong
	//float time = -TIME / 200.0;
	const vec3 debugLightDir = vec3(0.9, 0.1, 0.0);
	vec3 viewDir = normalize(relativePosition.xyz);
	vec3 halfwayDir = normalize(debugLightDir + viewDir); 
	float shininess = 16.0 * specularMap.r;
	float spec = pow(max(dot(normalColor.rgb, halfwayDir), 0.0), shininess);
	vec4 perPixelSpecular = vec4(sunLightColor, spec * specularMap.r);


	vec4 pointLights = pow(texture2D(TEXTURE_1, vec2(uv1.x, 0.0)), vec4(4.0));

	vec4 ambientOclusion = texture2D(TEXTURE_1, vec2(0.0, uv1.y));

	vec4 fakeShadow = clamp(pow(ambientOclusion * 1.025, vec4(500.0)),0.0,1.0);
	
	
	/*if(fakeShadow.r < 1.0 && fakeShadow.r > 0.0){
		fakeShadow.rgb *= noise(position.xy) + 0.5;
 	}*/
	

	//fake effect when light bounses from surface if hits it with very small angle
	const float fresnelFactor = 5.0;
	float fresnel = pow(1.0 - dot(normalColor.rgb, viewDir), fresnelFactor * specularMap.r);

	if(fresnel > 1.0) {//because of our fake normals we should do this trick
		fresnel = pow(1.0 - dot(normalColor.rgb, -viewDir), fresnelFactor * specularMap.r);
	}

	if(isWater){
		float farWaterFresnel = pow(1.0 - dot(vec3(0.0,1.0,0.0), viewDir), fresnelFactor);
		fresnel = mix(fresnel, 1.0, farWaterFresnel);
	}

	//mix lighting
	vec3 resultLighting = ambientOclusion.rgb * skyLightColor * skyDot * 0.5;
	vec4 perPixelFresnel = vec4(resultLighting, fresnel * specularMap.r);
	resultLighting += sunLightColor * sunDot * fakeShadow.rgb * 2.0;
	resultLighting += pointLights.rgb;
	diffuse.rgb *= resultLighting.rgb * 1.8;
	diffuse.rgb = mix(diffuse.rgb, perPixelFresnel.rgb * 4.0, perPixelFresnel.a);
	diffuse.rgb = mix(diffuse.rgb, perPixelSpecular.rgb * 2.0, pow(perPixelSpecular.a, 1.5) * fakeShadow.r);
#endif //ALWAYS_LIT


//here is a water
#ifndef SEASONS
	#if !USE_ALPHA_TEST && !defined(BLEND)
		//diffuse.a = inColor.a;//with this parameter we can detirmane if it's water or leaves 
	#endif //USE_ALPHA_TEST
		diffuse.rgb *= color.rgb;
		if(isWater){
			diffuse.rgb = mix(diffuse.rgb * 0.25, vec3(0.16, 0.24, 0.6) * 2.8, perPixelFresnel.a);
			diffuse.rgb = mix(diffuse.rgb, fakeShadow.rgb * vec3(1.0,1.0,1.5), perPixelSpecular.a);
			diffuse.a = perPixelFresnel.a + 0.5 + perPixelSpecular.a, 2.0;
		}

#else

	//vec2 uv = inColor.xy;
	//diffuse.rgb *= mix(vec3(1.0,1.0,1.0), texture2D( TEXTURE_2, uv).rgb*2.0, inColor.b);
	//diffuse.rgb *= inColor.aaa;
	//diffuse.a = 1.0;
#endif //SESONS;


	//TODO connect FOG_COLOR.rgb (available here 100%) and TIME attribute (hope is available) with ownFogColor value
	//to change its color depending on day/night cicle and weater
	if(!isWater){
		//add blue fog everywhere except water;
		diffuse.rgb = mix(diffuse.rgb, blueFog.rgb, blueFog.a);// 1.0/1.5 = 0.6666667
	}

	//TODO user actual position instead of relativePosition;	
	diffuse.rgb = mix(diffuse.rgb, milkyFog.rgb, milkyFog.a);
#ifdef FOG
//we dont have realativePosityon here, so it brakes everything
	/*fogColor.rgb = vec3(0.1,0.3,1.0);
	fogColor.a -= relativePosityon.y;
	diffuse.rgb = mix( diffuse.rgb, fogColor.rgb, clamp(fogColor.a, 0.0, 1.0) );
*/
#endif //FOG

	vec4 colorCorrectionContrast = vec4(1.5, 1.25, 1.0, 1.0);
	vec4 colorCorrectionTint = vec4(1.75,1.5,1.0,1.0);
	float colorCorrectionSaturation = 0.75;
	float grayScaleDiffuse = (diffuse.r + diffuse.g + diffuse.b)*0.3333333;
	diffuse.rgb = atan(pow(diffuse.rgb * colorCorrectionTint.rgb, colorCorrectionContrast.rgb));//avoid super bright areas (atan(x) can't be grater then 1.0)
	diffuse.rgb = mix(vec3(grayScaleDiffuse, grayScaleDiffuse, grayScaleDiffuse), diffuse.rgb, colorCorrectionSaturation);



	///////////////////////debuging section//////////////////////

	//debug texture coordinates
	//diffuse.rgb *= vec3(fract(uv0.x*32.0), fract(uv0.y*32.0), 1.0);

	//debug all lighting 
	//diffuse.rgb = sunLightPerPixel.rgb + skyLightPerPixel.rgb;
	//diffuse.rgb = mix(diffuse.rgb, perPixelFresnel.rgb, perPixelFresnel.a);
	//diffuse.rgb = mix(diffuse.rgb, perPixelSpecular.rgb, perPixelSpecular.a);

	//debug only reflective components
	//diffuse.rgb = mix(vec3(0.0), perPixelFresnel.rgb, perPixelFresnel.a);
	//diffuse.rgb = mix(diffuse.rgb, perPixelSpecular.rgb, perPixelSpecular.a);

	
	//diffuse.rgb = mix(vec3(0.1), perPixelSpecular.rgb, perPixelSpecular.a);


	//diffuse.rgb = mix(vec3(0.0), vec3(1.0), fract(time / 1000.0 + 0.5));

	//debug normals
	//diffuse.rgb = normalColor.rgb;

	//debug normalsOffset
	//diffuse.rg = localNormalCoord * 64.0;
	//diffuse.b = 0.0;
	//diffuse.a = 1.0;


	//dbug position
	//diffuse.rgb = sin(position.xyz/2.545) * 0.5 + 0.5;

	gl_FragColor = diffuse;
	//check if vim broke this file (looks like it happens sometimes :-/)
	//gl_FragColor = vec4(1.0,0.0,0.0,1.0);
#endif // BYPASS_PIXEL_SHADER
}
