// __multiversion__
// This signals the loading code to prepend either #version 100 or #version 300 ES as appropriate.
//#extension GL_EXT_shader_framebuffer_fetch : require

#include "fragmentVersionCentroid.h"

#if __VERSION__ >= 300
	#ifndef BYPASS_PIXEL_SHADER
		#if defined(TEXEL_AA) && defined(TEXEL_AA_FEATURE)
			_centroid in highp vec2 uv0;
			_centroid in highp vec2 uv1;
		#else
			_centroid in highp vec2 uv0;
			_centroid in highp vec2 uv1;
		#endif
	#endif //BYPASS_PIXEL_SHADER
#else
	#ifndef BYPASS_PIXEL_SHADER
		varying vec2 uv0;
		varying vec2 uv1;
	#endif	//BYPASS_PIXEL_SHADER
#endif //VERSION


varying float isRain;

varying float isWater;
varying float isUnderWater;
varying vec4 color;
varying highp vec4 position;// Get pixel position in world space (used for calculate fake normals)
varying highp vec4 relativePosition;// Calculates from vec4 position
//#ifdef FOG
	varying vec4 fogColor;
//#endif //FOG

#include "uniformShaderConstants.h"
#include "util.h"
#include "uniformPerFrameConstants.h"
#include "includes/env_detectors.glsl"
#include "includes/texture_mapping.glsl"
#include "includes/random.glsl"
#include "includes/color_correction.glsl"
#include "includes/reflections.glsl"


LAYOUT_BINDING(0) uniform sampler2D TEXTURE_0;
LAYOUT_BINDING(1) uniform sampler2D TEXTURE_1;
LAYOUT_BINDING(2) uniform sampler2D TEXTURE_2;

varying vec4 blueFog;
varying vec4 milkyFog;




void main()
{
	
	float isDay = detectDay(TEXTURE_1);
   	float isHell = detectHell(TEXTURE_1);
	float isSunrize = detectSunRize();

   

#ifdef BYPASS_PIXEL_SHADER
	gl_FragColor = vec4(1.0, 0, 0, 1.0);
	return;
#else 

/*#if USE_TEXEL_AA
	vec4 diffuse = texture2D_AA(TEXTURE_0,uv0);
#else*/


	////////////////////////////Mapping section///////////////////////////////////

	// By default (with default texture pack) result "megatexture" demensions is 1.0 x 0.5
	// but wtih my texture pack I have 1.0 x ture2D1.0. with your custom texuture pack you should check result texture  dimensions
	
	// Top left texture - default diffuse
	highp vec2 localDiffuseCoord = fract(uv0 * vec2(32.0)) * vec2(0.015625);// 1.0 / 64.0 = 0.015625
	vec4 diffuseMap = texelFetch(TEXTURE_0, ivec2((uv0 - localDiffuseCoord) * 1024.0), 0);
	vec4 diffuse = diffuseMap;
	
	vec3 normalMap = vec3(0.0);	
	vec3 normalVector = vec3(0.0);
	if(isWater < 0.9){
		// Bottom left texture - normalmap
		highp vec2 localNormalCoord = localDiffuseCoord - vec2(0.0, 0.015625);
		normalMap = texelFetch(TEXTURE_0, ivec2((uv0 - localNormalCoord) * 1024.0), 0).rgb;
	}
	
	// Top right texture - specular map
	highp vec2 localSpecularCoord = localDiffuseCoord - vec2(0.015625, 0.0);// 1.0/64.0 = 0.015625
    highp vec4 specularMap = clamp(texelFetch(TEXTURE_0, ivec2((uv0 - localSpecularCoord) * 1024.0), 0),0.01, 1.0);

	
	float  wetness = 0.0;
	if(isRain > 0.1 && isWater < 0.1){
		wetness = mapPuddles(TEXTURE_0, position.xz, isRain);	
	}

	highp float metalness = mix(pow(specularMap.g, 4.0), 0.0, wetness);
	highp float roughness = mix(pow(specularMap.r, 4.0), 1.0, wetness);



#if defined(BLEND)
	if(isWater >  0.9){
		normalMap = mapWaterNormals(TEXTURE_0);
		metalness = 0.0;
		roughness = 1.0;
		diffuse.rgb *= 0.5;
	}
#endif
	

//#endif //USE_TEXEL_AA


// Maybe it's about LOD (far trees and water becomes opaque)
#ifdef SEASONS_FAR
	diffuse.a = 1.0;
#endif //SEASONS_FAR


#if USE_ALPHA_TEST
	#ifdef ALPHA_TO_COVERAGE
	#define ALPHA_THRESHOLD 0.05
	#else
	#define ALPHA_THRESHOLD 0.5
	#endif //APLPHA_TO_COVERAGE
	if(diffuse.a < ALPHA_THRESHOLD)
		discard;// Cutout leaves and grass
#endif //USE_ALPHA_TEST
	

#if !defined(ALWAYS_LIT)

	highp vec3 dp1 = dFdx(position.xyz);
	highp vec3 dp2 = dFdy(position.xyz);

	vec3 initnormalVector = normalize(cross(dp1, dp2));
	normalVector = initnormalVector;

	

	//water, grass and leaves color
	diffuse.rgb *= color.rgb;


	// Dark wetness color (affected by fresnel later)
	wetness = max(initnormalVector.g * wetness, 0.5);
	diffuse.rgb = mix(diffuse.rgb, vec3(0.15,0.15,0.15), wetness * isRain);

	normalVector = rotateNormals(normalVector, normalMap);
	
	
	///////////////////////Lighting section//////////////////////////

	const vec3 skyLightDirection  = vec3(0.0,1.0,0.0);
	const float skyLightWrapping = 8.0;
	float skyDot = max((dot(skyLightDirection, normalVector) + skyLightWrapping)/(1.0 + skyLightWrapping),0.0);
	
	vec3 rainSkyLightColor = vec3(0.4, 0.4, 0.4) * isRain * isDay;
	vec3 clearSkyLightColor = pow(FOG_COLOR.rgb, vec3(0.6)) /** isDay */* (1.0 - isRain); 
	
	if(isHell > 0.9){
		clearSkyLightColor = vec3(0.0);
		rainSkyLightColor = vec3(0.0);
	}
	
	vec3 skyLightColor = rainSkyLightColor + clearSkyLightColor;

	const vec3 sunLightDirection = vec3(0.55,0.4,0.05);
	float sunDot = max(dot(sunLightDirection, normalVector), 0.0);	
	const vec3 sunLightColor = vec3(1.0, 0.88, 0.69);
	const vec3 moonLightColor = vec3(0.35, 0.6,1.0) * 0.35;
	
	
	// Blinn-phong
	highp vec3 debugLightDir = vec3(0.975, 0.025, 0.0);
	highp vec3 viewDir = normalize(relativePosition.xyz);
	highp vec3 halfwayDir = normalize(debugLightDir + viewDir); 
	highp float shininess = 512.0 * roughness;
	highp float spec = pow(max(dot(normalVector, halfwayDir), 0.0), shininess) * (1.0 - isRain);
	

	// Phong (fake halo effect)
	float haloPhongIntecity = 0.06 * isSunrize;
	vec3 reflectDir = reflect(-debugLightDir, normalVector);
	float haloPhong = pow(max(dot(viewDir, reflectDir), 0.0), 8.0) * haloPhongIntecity;

	// The same for onther light source (sunrize, sunset)
	highp vec3 reverseDebugLightDir = vec3(-0.975, 0.025, 0.0);
	reflectDir = reflect(-reverseDebugLightDir, normalVector);
	float secondHaloPhong = pow(max(dot(viewDir, reflectDir), 0.0), 8.0) * haloPhongIntecity;

	spec += haloPhong + secondHaloPhong;

	vec4 sunLightSpecular = vec4(sunLightColor * 2.0, spec * (isDay - isRain));
	vec4 moonLightSpecular = vec4(moonLightColor, spec * ((1.0 - isDay) - isRain));

	// Torches, lamps and lava lights
	float srcPointLights = uv1.x;
	float nearPointLightsBrightness = pow(srcPointLights * 1.15, 32.0);
	float overalPointLightsBrightness = pow(srcPointLights, 2.0) * 0.5 + nearPointLightsBrightness;
	overalPointLightsBrightness *= 2.0;
	overalPointLightsBrightness = clamp(overalPointLightsBrightness, 0.0, 2.0);
	vec3 pointLightsTint = vec3(1.0, 0.66, 0.33);
	vec4 pointLights = vec4(1.0);
	pointLights.rgb = vec3(overalPointLightsBrightness) * pointLightsTint;


	vec4 ambientOclusion = vec4(uv1.y + isHell* 0.5);
	vec4 fakeShadow = clamp(pow(ambientOclusion * 1.15, vec4(128.0)),0.0,1.0);
	vec4 fakeMoonShadow = clamp(pow(ambientOclusion * 1.15, vec4(64.0)), 0.0, 1.0);


	if(isUnderWater > 0.9){
		fakeShadow += vec4(mapCaustics(TEXTURE_0, position.xyz));
	}
	
	

	spec = pow(max(dot(normalVector, viewDir), 0.0), shininess * 0.25);
	vec4 pointLightsSpec = vec4(pow(min(pointLights.rgb * 3.0, 1.0), vec3(2.0)), spec * pointLights.r);
	
	

	// Fake effect when surface is hit at a very small angle and light bounces from the surface 
	float fresnelFactor = 6.0;
	float fresnel = max(1.0 - dot(normalVector, viewDir), 0.0);
	fresnel = min(pow(fresnel, fresnelFactor), 1.0);

	
	float farWaterFresnel = min(pow(1.0 - dot(initnormalVector, viewDir), fresnelFactor), 1.0);
	fresnel = mix(fresnel, 1.0, farWaterFresnel * isWater);
	

	// The same tweak but with wetness
	float puddlesFresnel = pow(1.0 - dot(initnormalVector.rgb, viewDir), fresnelFactor * 0.5 );	
	fresnel = mix(fresnel, puddlesFresnel, wetness * isRain * initnormalVector.g * (1.0 - isWater));
	


	vec4 pointLightsFresnel = vec4(pointLights.rgb, fresnel * (2.0 - (isDay + fakeShadow)));


	// Mix lighting
	vec3 resultLighting = ambientOclusion.rgb * skyLightColor * skyDot * 0.5;	
	vec4 skyLightReflected = vec4(resultLighting * 2.0, fresnel * (clamp(0.25 + (specularMap.r * 0.75) + isRain * wetness, 0.0, 1.0)));

	resultLighting += pointLights.rgb;
	resultLighting += sunLightColor * sunDot * fakeShadow.r * isDay * (1.0 - isRain);
	resultLighting += vec3(isHell * 0.175);// Ambient highlighting in hell
	resultLighting += moonLightColor * sunDot * fakeMoonShadow.r * (1.0 - isDay) * (1.0 - isRain );
	
	diffuse.rgb *= resultLighting.rgb * 1.8 * (1.0 - metalness); 

	
	vec3 reflection = buildReflection(relativePosition.xyz, normalVector, skyLightReflected, isRain, roughness) * 1.0;

    reflection += sunLightSpecular.rgb * sunLightSpecular.a * fakeShadow.r * 4.0;
	reflection += moonLightSpecular.rgb * moonLightSpecular.a * fakeShadow.r * 4.0;
	reflection += pointLightsSpec.rgb * pointLightsSpec.a * 10.0;



	vec3 metalnessReflection = diffuseMap.rgb * reflection * metalness;
	vec3 insulatorsReflection = reflection * (1.0 - metalness) * roughness;
	vec3 resultReflections = metalnessReflection + insulatorsReflection;

	float f0 = metalness * 0.5 + (1.0 - metalness) * 0.05;
	float f1 = 1.0;
	
	
	diffuse.rgb = mix(diffuse.rgb, resultReflections, f0 + skyLightReflected.a * f1);

	diffuse.a = max(diffuse.a, skyLightReflected.a + sunLightSpecular.a +  moonLightSpecular.a + pointLightsSpec.a);	
	// diffuse.rgb = vec3(1.0, 0.0, 0.0);	
#endif //ALWAYS_LIT


#if defined(BLEND)

#endif //BLEND

	//Add blue fog everywhere when weather is good except water and hell
	diffuse.rgb = mix(diffuse.rgb, blueFog.rgb, blueFog.a * pow(isDay, 2.0) * (1.0 - isWater) * (1.0 - isRain) * (1.0 - isHell));// 1.0/1.5 = 0.6666667
	
	//TODO: user actual position instead of relativePosition
	vec3 milkyFogColor = mix(vec3(0.1), milkyFog.rgb, isDay);
	diffuse.rgb = mix(diffuse.rgb, milkyFogColor, milkyFog.a * (1.0 - isHell));
// #ifdef FOG
	diffuse.rgb = mix( diffuse.rgb, clearSkyLightColor + rainSkyLightColor * 0.3, fogColor.a);
// #endif //FOG

	diffuse.rgb = colorCorrection(diffuse.rgb);


	// Default fog in hell because it has no skyplane
	if(isHell > 0.9){
		diffuse.rgb = mix( diffuse.rgb, FOG_COLOR.rgb, fogColor.a);
	}

	///////////////////////Debuging section//////////////////////

	// Debug texture coordinates
	//diffuse.rgb *= vec3(fract(uv0.x*32.0), fract(uv0.y*32.0), 1.0);

	
	// Debug position
	//diffuse.rgb = sin(position.xyz/2.545) * 0.5 + 0.5;

    // Debug tile texture
	// diffuse = texelFetch(TEXTURE_0, ivec2(position.xz * 128.0), 0);

	//vec3 sphereNormal = (normalize(position.xyz) + 1.0) / 2.0;
	//diffuse.rgb = sphereNormal;

	//diffuse.rgb = texelFetch(TEXTURE_1, ivec2(position.xz * 4.0),0).rgb;
	//diffuse.rgb = texture2D(TEXTURE_1, vec2(0.0, 1.0)).rgb;
	
	gl_FragColor = diffuse;
#endif // BYPASS_PIXEL_SHADER
}
