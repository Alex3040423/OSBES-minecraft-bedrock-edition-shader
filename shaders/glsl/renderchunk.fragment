// __multiversion__
// This signals the loading code to prepend either #version 100 or #version 300 es as apropriate.

#include "fragmentVersionCentroid.h"

#if __VERSION__ >= 300
	#ifndef BYPASS_PIXEL_SHADER
		#if defined(TEXEL_AA) && defined(TEXEL_AA_FEATURE)
			_centroid in highp vec2 uv0;
			_centroid in highp vec2 uv1;
		#else
			_centroid in vec2 uv0;
			_centroid in vec2 uv1;
		#endif
	#endif //BYPASS_PIXEL_SHADER
#else
	#ifndef BYPASS_PIXEL_SHADER
		varying vec2 uv0;
		varying vec2 uv1;
	#endif	//BYPASS_PIXEL_SHADER
#endif //VERSION

varying vec4 color;//TODO what is this color??
vec4 normalColor;// fake normal vector will be stored here or may be later will be passed from vertex shader
varying highp vec4 position;// get pixel position in world space (used for calculate fake normals)
varying highp vec3 relativePosition;//calculates from vec4 position
#ifdef FOG
	varying vec4 fogColor;
#endif //FOG

#include "uniformShaderConstants.h"
#include "util.h"
#include "uniformPerFrameConstants.h"
LAYOUT_BINDING(0) uniform sampler2D TEXTURE_0;
LAYOUT_BINDING(1) uniform sampler2D TEXTURE_1;
LAYOUT_BINDING(2) uniform sampler2D TEXTURE_2;

varying highp float ownFogAlpha;


float noise(highp vec2 coord){
	return fract(sin(dot(coord.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

float smoothNoise(vec2 o){
	vec2 a = fract(o.xy);
	vec2 b = floor(o.xy);
	
	float t = noise(b);
	float tt = noise(b + vec2(1.0, 0.0));
	float d = mix(t, tt, a.x);

	float k = noise(b + vec2(0.0, 1.0));
	float kk = noise(b + vec2(1.0, 1.0));
	float e = mix(k, kk, a.x);
	return mix(d, e, a.y);
}

void main()
{	
	vec4 inColor = color;
#ifdef BYPASS_PIXEL_SHADER
	gl_FragColor = vec4(1.0, 0, 0, 1.0);
	return;
#else 

#if USE_TEXEL_AA
	vec4 diffuse = texture2D_AA(TEXTURE_0,uv0);
#else

	//by default texture demensions 1.0, 0.5
	highp vec2 textureScale = vec2(32.0,32.0);//but here we has 1.0, 1.0. with custom texuture pack you should check result texture  dimensions
	//top left texture - default diffuse
	highp vec2 localDiffuseCoord = fract(uv0 * textureScale)/(textureScale * 2.0);
	//top right texture - specular map
	highp vec2 localSpecularCoord = localDiffuseCoord - vec2(1.0/64.0, 0.0);


	//debug check result texture (you should find block with top left corner texture  and place it somewhere in the world)
	//vec4 diffuse = texture2D(TEXTURE_0, uv0 * 16.0 - vec2(0.5, 0.0));
	
	vec4 diffuse = texture2D(TEXTURE_0, uv0 - localDiffuseCoord);
	vec4 specularMap = clamp(texture2D(TEXTURE_0, uv0 - localSpecularCoord),0.01, 1.0);
	highp vec4 normalMap = vec4(0.0);
	
	normalColor.rgb = vec3(0.0,0.0,0.0);
	if(inColor.b > inColor.g * 0.8 && inColor.b > inColor.r * 1.1){
		normalColor.rgb = vec3(0.0,1.0,0.0);
		highp float t = TIME * 0.25;
		vec2 waterNormalMapPosition = vec2(1.5/32.0);	

		normalMap = texture2D(TEXTURE_0, fract(position.xz + t)/64.0 + waterNormalMapPosition);
		normalMap += texture2D(TEXTURE_0, fract(position.xz*0.5 - t * 0.5)/64.0 + waterNormalMapPosition);
		normalMap += texture2D(TEXTURE_0, fract(position.xz*0.25 + t * 0.2)/64.0 + waterNormalMapPosition);
		normalMap += texture2D(TEXTURE_0, fract(position.xz*0.125 - t * 0.1)/64.0 + waterNormalMapPosition);
		normalMap *= 0.25;
	}else{
		//bottom left  texture - normalmap
		highp vec2 localNormalCoord = localDiffuseCoord - vec2(0.0, 1.0/64.0);
		normalMap = texture2D(TEXTURE_0, uv0 - localNormalCoord);
	}
	
#endif //USE_TEXEL_AA


//maybe it's about LOD (far trees and water becomes opaque)
#ifdef SEASONS_FAR
	diffuse.a = 1.0;
#endif //SEASONS_FAR


#if USE_ALPHA_TEST
	#ifdef ALPHA_TO_COVERAGE
	#define ALPHA_THRESHOLD 0.05
	#else
	#define ALPHA_THRESHOLD 0.5
	#endif //APLPHA_TO_COVERAGE
	if(diffuse.a < ALPHA_THRESHOLD)
		discard;//catout leaves and grass
#endif //USE_ALPHA_TEST
	

#if defined(BLEND)
	//diffuse.a *= inColor.a;
#endif //BLEND

#if !defined(ALWAYS_LI)
	//TODO try to calculate not doublesided normals
	//TODO or try to get normals from vertex shader (currently it is not available or just returns messy stuff) 
	highp float posMult = 1.0;
	while(length(normalColor.rgb) < 0.5 && posMult < 128.0){// decrease position fraction scale intyl normal color isn't 0
		normalColor.rgb = vec3(1.0 - ceil(fract(position.xyz * posMult)));
		posMult *= 2.0;
	}
	//after previous calculation normalColor for plants is black
	//todo maybe it can be used to derirmine if there is a plant;
	if(length(normalColor.rgb) < 0.5){
		normalColor.rgb = vec3(0.0,1.0,0.0);//make them green like they are locking forward		
	}

	//fake TBN transformations for normalmapps
 	if(length(normalMap.rgb) > 0.5){

   		float normalMapStrength = 1.0;
   

		if (normalColor.b == 1.0){
			normalMap.g = 1.0 - normalMap.g;//OpenGl style G flip
    		normalMap.rgb = normalMap.rgb * 2.0 - 1.0;
    		normalMap.rg *= normalMapStrength;
    		normalColor.rgb = normalize(normalMap.rgb);
 
		}
		if(normalColor.g == 1.0){
			float temp = normalMap.g;
			normalMap.g = normalMap.b;
			normalMap.b = temp;
    		normalMap.rgb = normalMap.rgb * 2.0 - 1.0;
    		normalMap.rb *= normalMapStrength;
    		normalColor.rgb = normalize(normalMap.rgb);
		}
		if(normalColor.r == 1.0){
			normalMap.g = 1.0 - normalMap.g;//OpenGl style G flip
			float temp = normalMap.r;
			normalMap.r = normalMap.b;
			normalMap.b = temp;
    		normalMap.rgb = normalMap.rgb * 2.0 - 1.0;
    		normalMap.gb *= normalMapStrength;
    		normalColor.rgb = normalize(normalMap.rgb);
		}
	}


	vec4 skyLightColor = vec4(0.45,0.7,1.1,0.0);//todo connect with time attribute
	vec3 skyLightDirection  = vec3(0.0,1.0,0.0);//todo connect with time attribute
	float skyLightWrapping = 4.0;//make sky lighting from sides too
	float dotAngle = max((dot(skyLightDirection, normalColor.rgb) + skyLightWrapping)/(1.0 + skyLightWrapping),0.0);
	vec4 skyLightPerPixel = skyLightColor * dotAngle;
	skyLightPerPixel.a = 1.0;



	vec3 sunLightDirection = vec3(0.5,0.4,0.1);//todo connect with time attribute
	vec3 sunLightColor = vec3(1.0, 0.9, 0.8);//todo connect with time attribute
	float sunDotAngle = max(dot(sunLightDirection, normalColor.rgb), 0.0);//todo use normalmaps to represent surface details
	vec4 sunLightPerPixel = vec4(sunLightColor * sunDotAngle, 0.0);

	//blinn-phong
	//float time = -TIME / 200.0;
	vec3 debugLightDir = vec3(0.9, 0.1, 0.0);
	highp vec3 viewDir = normalize(relativePosition.xyz);
	vec3 halfwayDir = normalize(debugLightDir + viewDir); 
	float shininess = 16.0 * specularMap.r;
	float spec = pow(max(dot(normalColor.rgb, halfwayDir), 0.0), shininess);
	vec4 perPixelSpecular = vec4(sunLightColor, spec * specularMap.r);


	vec4 pointLights = pow(texture2D(TEXTURE_1, vec2(uv1.x, 0.0)), vec4(4.0,4.0,4.0,4.0));

	vec4 ambientOclusion = texture2D(TEXTURE_1, vec2(0.0, uv1.y));

	vec4 fakeShadow = clamp(pow(ambientOclusion * 1.025, vec4(500.0, 500.0, 500.0, 500.0)),0.0,1.0);
	
	
	if(fakeShadow.r < 1.0 && fakeShadow.r > 0.0){
		fakeShadow.rgb *= noise(position.xy) + 0.5;
 	}
	

	//fake effect when light bounses from surface if hits it with very small angle
	float fresnelFactor = 5.0;
	highp vec3 V = normalize(relativePosition.xyz);
	vec3 N = normalize(normalColor.rgb);
	float fresnel = pow(1.0 - dot(N, V), fresnelFactor * specularMap.r);

	if(fresnel > 1.0) {//because of our fake normals we should do this trick
		V = normalize(-relativePosition.xyz);//minus relative position
		N = normalize(normalColor.rgb);
		fresnel = pow(1.0 - dot(N, V), fresnelFactor * specularMap.r);
	}


	if(inColor.b > inColor.g * 0.8 && inColor.b > inColor.r * 1.1){
		V  = normalize(relativePosition.xyz);
		float farWaterFresnel = pow(1.0 - dot(vec3(0.0,1.0,0.0), V), fresnelFactor);
		fresnel = mix(fresnel, 1.0, farWaterFresnel);
	}

	//mix lighting
	vec4 resultLighting = ambientOclusion * 0.5 * skyLightPerPixel;
	vec4 perPixelFresnel = vec4(resultLighting.rgb, fresnel * specularMap.r);
	resultLighting += sunLightPerPixel * fakeShadow * 2.0;
	resultLighting += pointLights;
	diffuse.rgb *= resultLighting.rgb * 1.8;
	diffuse.rgb = mix(diffuse.rgb, perPixelFresnel.rgb * 4.0, perPixelFresnel.a);
	diffuse.rgb = mix(diffuse.rgb, perPixelSpecular.rgb * 2.0, pow(perPixelSpecular.a, 1.5) * fakeShadow.r);
#endif //ALWAYS_LIT


//here is a water
#ifndef SEASONS
	#if !USE_ALPHA_TEST && !defined(BLEND)
		//diffuse.a = inColor.a;//with this parameter we can detirmane if it's water or leaves 
	#endif //USE_ALPHA_TEST
		diffuse.rgb *= inColor.rgb;
		if(diffuse.a < 1.0 && inColor.b > inColor.r && inColor.b > inColor.g * 0.83){
			diffuse.rgb = mix(diffuse.rgb * 0.25, vec3(0.16, 0.24, 0.6) * 2.8, perPixelFresnel.a);
			diffuse.rgb = mix(diffuse.rgb, fakeShadow.rgb * vec3(1.0,1.0,1.5), pow(perPixelSpecular.a, 2.0) * 1.0);
		}

		diffuse.a = perPixelFresnel.a + 0.5 + perPixelSpecular.a, 2.0;
#else

	//vec2 uv = inColor.xy;
	//diffuse.rgb *= mix(vec3(1.0,1.0,1.0), texture2D( TEXTURE_2, uv).rgb*2.0, inColor.b);
	//diffuse.rgb *= inColor.aaa;
	//diffuse.a = 1.0;
#endif //SESONS;


	//TODO connect FOG_COLOR.rgb (available here 100%) and TIME attribute (hope is available) with ownFogColor value
	//to change its color depending on day/night cicle and weater
	vec3 ownFogColor = vec3(0.25,0.35,1.0);
	if(inColor.b <= inColor.g && inColor.b <= inColor.r){
		diffuse.rgb = mix(diffuse.rgb, ownFogColor, clamp(atan(ownFogAlpha / (RENDER_DISTANCE / 1.5)),0.0,0.75));
	}

	//TODO user actual position instead of relativePosition;
	vec4 milkyFogColor = vec4 (0.6, 0.8, 1.4, 0.0);
	float milkyFogHeightOffset = 6.0;
	float milkyFogHeightAtenuation = 32.0;
	milkyFogColor.a = (relativePosition.y + milkyFogHeightOffset) / milkyFogHeightAtenuation;
	milkyFogColor.a = pow(clamp(milkyFogColor.a, 0.0, 1.0), 1.5);
	milkyFogColor.a *= ownFogAlpha / (RENDER_DISTANCE / 2.0);
	milkyFogColor.a = clamp(milkyFogColor.a, 0.0, 1.0);
	diffuse.rgb = mix(diffuse.rgb, milkyFogColor.rgb, milkyFogColor.a);
#ifdef FOG
//we dont have realativePosityon here, so it brakes everything
	/*fogColor.rgb = vec3(0.1,0.3,1.0);
	fogColor.a -= relativePosityon.y;
	diffuse.rgb = mix( diffuse.rgb, fogColor.rgb, clamp(fogColor.a, 0.0, 1.0) );
*/
#endif //FOG

	vec4 colorCorrectionContrast = vec4(1.5, 1.25, 1.0, 1.0);
	vec4 colorCorrectionTint = vec4(1.75,1.5,1.0,1.0);
	float colorCorrectionSaturation = 0.75;
	float grayScaleDiffuse = (diffuse.r + diffuse.g + diffuse.b)/3.0;
	diffuse.rgb = atan(pow(diffuse.rgb * colorCorrectionTint.rgb, colorCorrectionContrast.rgb));//avoid super bright areas (atan(x) can't be grater then 1.0)
	diffuse.rgb = mix(vec3(grayScaleDiffuse, grayScaleDiffuse, grayScaleDiffuse), diffuse.rgb, colorCorrectionSaturation);



	///////////////////////debuging section//////////////////////

	//debug texture coordinates
	//diffuse.rgb *= vec3(fract(uv0.x*32.0), fract(uv0.y*32.0), 1.0);

	//debug all lighting 
	//diffuse.rgb = sunLightPerPixel.rgb + skyLightPerPixel.rgb;
	//diffuse.rgb = mix(diffuse.rgb, perPixelFresnel.rgb, perPixelFresnel.a);
	//diffuse.rgb = mix(diffuse.rgb, perPixelSpecular.rgb, perPixelSpecular.a);

	//debug only reflective components
	//diffuse.rgb = mix(vec3(0.0), perPixelFresnel.rgb, perPixelFresnel.a);
	//diffuse.rgb = mix(diffuse.rgb, perPixelSpecular.rgb, perPixelSpecular.a);

	
	//diffuse.rgb = mix(vec3(0.1), perPixelSpecular.rgb, perPixelSpecular.a);


	//diffuse.rgb = mix(vec3(0.0), vec3(1.0), fract(time / 1000.0 + 0.5));

	//debug normals
	//diffuse.rgb = normalColor.rgb;

	//debug normalsOffset
	//diffuse.rg = localNormalCoord * 64.0;
	//diffuse.b = 0.0;
	//diffuse.a = 1.0;

	//dbug position
	//diffuse.rgb = sin(position.xyz/2.545) * 0.5 + 0.5;

	gl_FragColor = diffuse;
	//check if vim broke this file (looks like it happens sometimes :-/)
	//gl_FragColor = vec4(1.0,0.0,0.0,1.0);
#endif // BYPASS_PIXEL_SHADER
}
