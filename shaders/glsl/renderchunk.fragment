// __multiversion__
// This signals the loading code to prepend either #version 100 or #version 300 es as apropriate.

#include "fragmentVersionCentroid.h"

#if __VERSION__ >= 300
	#ifndef BYPASS_PIXEL_SHADER
		#if defined(TEXEL_AA) && defined(TEXEL_AA_FEATURE)
			_centroid in highp vec2 uv0;
			_centroid in highp vec2 uv1;
		#else
			_centroid in vec2 uv0;
			_centroid in vec2 uv1;
		#endif
	#endif //BYPASS_PIXEL_SHADER
#else
	#ifndef BYPASS_PIXEL_SHADER
		varying vec2 uv0;
		varying vec2 uv1;
	#endif	//BYPASS_PIXEL_SHADER
#endif //VERSION


varying float isRain;

varying float isWater;
varying vec4 color;//TODO what is this color??
vec4 normalColor;// fake normal vector will be stored here or may be later will be passed from vertex shader
varying highp vec4 position;// get pixel position in world space (used for calculate fake normals)
varying highp vec3 relativePosition;//calculates from vec4 position
#ifdef FOG
	varying vec4 fogColor;
#endif //FOG

#include "uniformShaderConstants.h"
#include "util.h"
#include "uniformPerFrameConstants.h"
LAYOUT_BINDING(0) uniform sampler2D TEXTURE_0;
LAYOUT_BINDING(1) uniform sampler2D TEXTURE_1;
LAYOUT_BINDING(2) uniform sampler2D TEXTURE_2;

varying vec4 blueFog;
varying vec4 milkyFog;


float noise(highp vec2 coord){
	return fract(sin(dot(coord.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

vec4 texture2D_b(sampler2D t, highp vec2 uv, vec2 baseOffset)
{
	uv += baseOffset;

	vec2 textureSize = vec2(1024.0);
	vec2 texelSize = 1.0/textureSize;
	vec2 f = fract( uv * textureSize );
	//uv += ( .5 - f ) * texelSize;    // move uv to texel centre

	vec4 tl = texture2D(t, uv);



	highp vec2 tr_coord = uv + vec2(texelSize.x, 0.0);
	if(tr_coord.x > baseOffset.x + 1.0/64.0){
		tr_coord.x -= 1.0/64.0;
	}
    	vec4 tr = texture2D(t, tr_coord);
	
	

	highp vec2 bl_coord = uv + vec2(0.0, texelSize.y);
	if(bl_coord.y > baseOffset.y + 1.0/64.0){
		bl_coord.y -= 1.0/64.0;
	}
	vec4 bl = texture2D(t, bl_coord);

	

	highp vec2 br_coord = uv + vec2(texelSize.x, texelSize.y);
	if(br_coord.x > baseOffset.x + 1.0/64.0){
		br_coord.x -= 1.0/64.0;
	}
	if(br_coord.y > baseOffset.y + 1.0/64.0){
		br_coord.y -= 1.0/64.0;
	}
	vec4 br = texture2D(t, br_coord);
	
	

	vec4 tA = mix( tl, tr, f.x );
	vec4 tB = mix( bl, br, f.x );
	//return vec4(0.5);
	return mix( tA, tB, f.y );
}

highp vec2 parallax(highp vec2 uv, highp vec3 viewDir){
	
	highp vec3 n = vec3(0.0, 1.0, 0.0);
	highp vec3 t = vec3(0.0, 0.0, 1.0);
	highp vec3 b = vec3(1.0, 0.0, 0.0);

	highp mat3 tbn = transpose(mat3(t, b, n));

	viewDir = tbn * viewDir;


	//viewDir ;

	highp float height_scale = 0.01;

	//highp float height = texture2D(TEXTURE_0, uv).b;
	highp float height = 0.5;
	highp vec2 p = viewDir.xy / viewDir.z * (height * height_scale);

	//return uv;
	return uv - p;
}


void main()
{
    
    float isDay = pow(texture2D(TEXTURE_1, vec2(0.0, 1.0)).b, 4.0);
#ifdef BYPASS_PIXEL_SHADER
	gl_FragColor = vec4(1.0, 0, 0, 1.0);
	return;
#else 

#if USE_TEXEL_AA
	vec4 diffuse = texture2D_AA(TEXTURE_0,uv0);
#else


	////////////////////////////mapping section///////////////////////////////////

	//by default (with default texture pack) result "megatexture" demensions is 1.0 x 0.5
	//but wtih my texture pack I have 1.0 x 1.0. with your custom texuture pack you should check result texture  dimensions
	
	//top left texture - default diffuse
	highp vec2 localDiffuseCoord = fract(uv0 * vec2(32.0)) * vec2(0.015625);// 1.0 / 64.0 = 0.015625
	//top right texture - specular map
	highp vec2 localSpecularCoord = localDiffuseCoord - vec2(0.015625, 0.0);// 1.0/64.0 = 0.015625


	//debug checking result texture (you should find block with top left corner texture  and place it somewhere in the world)
	//vec4 diffuse = texture2D(TEXTURE_0, uv0 * 32.0 - vec2(1.0, 0.0));
	
	vec4 diffuse = texture2D(TEXTURE_0, uv0 - localDiffuseCoord);
	//vec4 diffuse = texture2D(TEXTURE_0, parallax(uv0 - localDiffuseCoord, relativePosition.xyz));


	vec4 specularMap = clamp(texture2D(TEXTURE_0, uv0 - localSpecularCoord),0.01, 1.0);
	vec4 normalMap = vec4(0.0);	
	normalColor.rgb = vec3(0.0);
	
	vec4  puddles = vec4(0.0, 0.0, 0.0, 0.0);

	if(isRain > 0.1 && isWater < 0.1){
		
		float puddlesSharpness = 8.0;
		float puddlesCovering = 2.0;

		vec2 noiseTextureOffset = vec2(5.0/64.0, 1.0/64.0); 
		puddles = texture2D_b(TEXTURE_0, fract(position.xz * 0.0625)*0.015625, noiseTextureOffset);
		//puddles = texture2D(TEXTURE_0, fract(position.xz * 0.0625)*0.015625 + noiseTextureOffset);
		//puddles.rgb = pow(puddles.rgb, vec3(2.0));
		puddles.rgb = pow(puddles.rgb * isRain * puddlesCovering, vec3(puddlesSharpness));
		puddles.rgb = clamp(puddles.rgb, 0.25, 1.0);

	}

	if(isWater >  0.9){
		normalColor.rgb = vec3(0.0,1.0,0.0);
		highp float t = TIME * 0.1;
		
		float wnScale = 1.0;

		/*
		normalMap = texture2D_b(TEXTURE_0, fract(position.xz* 0.5 *wnScale + t * wnScale  ) * 0.015625 + 1.5/32.0);
		normalMap += texture2D_b(TEXTURE_0, fract(position.xz*0.25 * wnScale - t * wnScale) * 0.015625 + 1.5/32.0);
		normalMap += texture2D_b(TEXTURE_0, fract(position.xz*0.125 * wnScale - t * wnScale) * 0.015625 + 1.5/32.0);
		normalMap += texture2D_b(TEXTURE_0, fract(position.xz*0.0625 * wnScale - t * wnScale) * 0.015625 + 1.5/32.0);
		*/


		
		// 1.0/64.0 = 0.0156251          1.5 / 32.0 =  0.046875 (water normal map offset)
		normalMap = texture2D(TEXTURE_0, fract(position.xz*0.5*wnScale + t*wnScale)*0.015625 + 0.046875);
		normalMap += texture2D(TEXTURE_0, fract(position.xz*0.25*wnScale - t*wnScale)*0.015625 + 0.046875);// 
		normalMap += texture2D(TEXTURE_0, fract(position.xz*0.125*wnScale + t*wnScale)*0.015625 + 0.046875);
		normalMap += texture2D(TEXTURE_0, fract(position.xz*0.0625*wnScale - t*wnScale*0.0625)*0.015625 + 0.046875);
	
		//normalMap *= 0.5;
		//normalMap *= 0.33;
		normalMap *= 0.25;
		//normalMap.b = clamp(normalMap.b, 0.5, 1.0);

	}else{
		//bottom left  texture - normalmap
		highp vec2 localNormalCoord = localDiffuseCoord - vec2(0.0, 0.015625);
		normalMap = texture2D(TEXTURE_0, uv0 - localNormalCoord);
	}
	
#endif //USE_TEXEL_AA


//maybe it's about LOD (far trees and water becomes opaque)
#ifdef SEASONS_FAR
	diffuse.a = 1.0;
#endif //SEASONS_FAR


#if USE_ALPHA_TEST
	#ifdef ALPHA_TO_COVERAGE
	#define ALPHA_THRESHOLD 0.05
	#else
	#define ALPHA_THRESHOLD 0.5
	#endif //APLPHA_TO_COVERAGE
	if(diffuse.a < ALPHA_THRESHOLD)
		discard;//catout leaves and grass
#endif //USE_ALPHA_TEST
	

#if defined(BLEND)
	//diffuse.a *= inColor.a;
#endif //BLEND

#if !defined(ALWAYS_LIT)
	
	////////////////////////////normal maps and lighting section////////////////////////////////

	//TODO try to calculate not doublesided normals
	//TODO or try to get normals from vertex shader (currently it is not available or just returns messy stuff) 
	if(length(normalColor.rgb) < 0.5 ){// decrease position fraction scale intyl normal color isn't 0
		normalColor.rgb = vec3(1.0 - ceil(fract(position.xyz * 2.0)));
		if(length(normalColor.rgb) < 0.5){
			normalColor.rgb = vec3(1.0 - ceil(fract(position.xyz * 256.0)));
		}
	}
	//after previous calculation normalColor for plants is black
	//todo maybe it can be used to derirmine if there is a plant;
	if(length(normalColor.rgb) < 0.5){
		normalColor.rgb = vec3(0.0,1.0,0.0);//make them green like they are locking forward		
	}



	diffuse.rgb *= color.rgb;

	if(normalColor.g == 1.0){	
		diffuse.rgb = mix(diffuse.rgb, vec3(0.1,0.1,0.1),puddles.r * 0.75);
	}else{
		puddles.r = 0.5;
	}


	//fake TBN transformations for normalmapps
 	if(length(normalMap.rgb) > 0.9){
		
		float normalMapStrength = 0.5;

		if(normalColor.g == 1.0){
			normalMap.gb = normalMap.bg;
			normalMap.rgb = normalMap.rgb * 2.0 - 1.0;
			normalMap.rb *= normalMapStrength;
    			normalColor.rgb = normalize(normalMap.rgb);
		}else{

			if (normalColor.b == 1.0){
				normalMap.g = 1.0 - normalMap.g;//OpenGl style G flip
				normalMap.rgb = normalMap.rgb * 2.0 - 1.0;
				normalMap.rg *= normalMapStrength;
    				normalColor.rgb = normalize(normalMap.rgb);
 
			}else{

				if(normalColor.r == 1.0){
					normalMap.g = 1.0 - normalMap.g;//OpenGl style G flip
					normalMap.rb = normalMap.br;
					normalMap.rgb = normalMap.rgb * 2.0 - 1.0;
					normalMap.gb *= normalMapStrength;
    					normalColor.rgb = normalize(normalMap.rgb);
				}
			}
		}
	}






	///////////////////////lighting section//////////////////////////

	const vec3 skyLightDirection  = vec3(0.0,1.0,0.0);//todo connect with time attribute
	const float skyLightWrapping = 4.0;//make sky lighting from sides too
	float skyDot = max((dot(skyLightDirection, normalColor.rgb) + skyLightWrapping)/(1.0 + skyLightWrapping),0.0);
	
	vec3 rainSkyLightColor = vec3(0.5, 0.5, 0.5) * isRain * 4.0;
	vec3 clearSkyLightColor = vec3(0.4, 0.68, 1.1) * clamp(isDay, 0.0, 1.0) * (1.0 - isRain) * 4.0;

	vec3 skyLightColor = rainSkyLightColor + clearSkyLightColor;

	const vec3 sunLightDirection = vec3(0.55,0.4,0.05);//todo connect with time attribute
	float sunDot = max(dot(sunLightDirection, normalColor.rgb), 0.0);//todo use normalmaps to represent surface details	
	const vec3 sunLightColor = vec3(1.2, 1.1, 0.9) * 4.0;//todo connect with time attribute
	const vec3 moonLightColor = vec3(0.5, 0.75,1.0) * 1.0;


	//blinn-phong
	//float time = -TIME / 200.0;

	const vec3 debugLightDir = vec3(0.95, 0.05, 0.0);
	vec3 viewDir = normalize(relativePosition.xyz);
	vec3 halfwayDir = normalize(debugLightDir + viewDir); 
	float shininess = 64.0 * specularMap.r;
	float spec = pow(max(dot(normalColor.rgb, halfwayDir), 0.0), shininess);
	vec4 perPixelSpecular = vec4(sunLightColor, spec * specularMap.r * (isDay - isRain));


	vec4 originalPointLights = texture2D(TEXTURE_1, vec2(uv1.x, 0.0));
	float darkLightsDivider = 8.0;
	float brightLightsAtennuation = 6.0;

	vec4 pointLights  = (log(originalPointLights) + 2.0)/darkLightsDivider;
	pointLights += pow(originalPointLights, vec4(brightLightsAtennuation)) * (1.0 - (1.0/(darkLightsDivider/2.0)));
	

	vec3 pointLightsTint = vec3(1.5, 0.75, 0.375);
	pointLights.rgb *= pointLightsTint;

	vec4 ambientOclusion = texture2D(TEXTURE_1, vec2(0.0, uv1.y));

	vec4 fakeShadow = clamp(pow(ambientOclusion * 1.025, vec4(500.0)),0.0,1.0);
	vec4 fakeMoonShadow = clamp(pow(ambientOclusion * 2.5, vec4(64.0)), 0.0, 1.0);
	
	
	if(fakeShadow.r < 1.0 && fakeShadow.r > 0.0){
		fakeShadow.rgb *= noise(position.xy) + 0.75;
 	}
	

	//fake effect when light bounses from surface if hits it with very small angle
	const float fresnelFactor = 5.0;
	float fresnel = pow(1.0 - dot(normalColor.rgb, viewDir), fresnelFactor * (0.5 + isRain*0.5));

	if(fresnel > 1.0) {//because of our fake normals we should do this trick
		fresnel = pow(1.0 - dot(normalColor.rgb, -viewDir), fresnelFactor * specularMap.r);
	}
	
	//far water tweak
	if(isWater >  0.9){
		float farWaterFresnel = pow(1.0 - dot(vec3(0.0,1.0,0.0), viewDir), fresnelFactor);
		fresnel = mix(fresnel, 1.0, farWaterFresnel);
	}

	//the same tweak with puddles
	if(isRain > 0.5 && normalColor.g > 0.5 && isWater < 0.1){
		float farPuddlesFresnel = pow(1.0 - dot(vec3(0.0, 1.0, 0.0), viewDir), fresnelFactor/ 4.0);
		if(farPuddlesFresnel > 1.0){
			farPuddlesFresnel = pow(1.0 - dot(vec3(0.0, 1.0, 0.0), -viewDir), fresnelFactor / 4.0);	
		}	
		fresnel = mix(fresnel, 1.0, farPuddlesFresnel);
	}


	//mix lighting
	vec3 resultLighting = ambientOclusion.rgb * skyLightColor * skyDot * 0.5;
	vec4 perPixelFresnel = vec4(resultLighting, fresnel * (clamp(0.25 + (specularMap.r * 0.75) + isRain * puddles.r, 0.0, 1.0)));
	resultLighting += sunLightColor * sunDot * fakeShadow.r * 2.0 * isDay;
	resultLighting += moonLightColor * sunDot * fakeMoonShadow.r * (1.0 - isDay);
	resultLighting += pointLights.rgb;
	diffuse.rgb *= resultLighting.rgb * 1.8;
	diffuse.rgb = mix(diffuse.rgb, perPixelFresnel.rgb, perPixelFresnel.a);
	diffuse.rgb = mix(diffuse.rgb, perPixelSpecular.rgb, perPixelSpecular.a * fakeShadow.r);
#endif //ALWAYS_LIT


//here is a water
#ifndef SEASONS
	#if !USE_ALPHA_TEST && !defined(BLEND)
		//diffuse.a = inColor.a;//with this parameter we can detirmane if it's water or leaves 
	#endif //USE_ALPHA_TEST
		//todo move to default pipeline with default fog and sun colors
		//diffuse.rgb *= color.rgb;
		if(isWater > 0.9){
			diffuse.rgb = mix(diffuse.rgb * 0.25, perPixelFresnel.rgb * 1.75, pow(perPixelFresnel.a, 2.0));
			diffuse.rgb = mix(diffuse.rgb, fakeShadow.rgb * sunLightColor, pow(perPixelSpecular.a * 1.3, 4.0));
		///	diffuse.a = perPixelFresnel.a + 0.5 + clamp(perPixelSpecular.a * 2.0, 0.0, 1.0);
			diffuse.a = perPixelFresnel.a + pow(perPixelSpecular.a * 1.3, 4.0);
			diffuse.a = clamp(diffuse.a + 0.5, 0.0, 1.0);
		}

#else

	//vec2 uv = inColor.xy;
	//diffuse.rgb *= mix(vec3(1.0,1.0,1.0), texture2D( TEXTURE_2, uv).rgb*2.0, inColor.b);
	//diffuse.rgb *= inColor.aaa;
	//diffuse.a = 1.0;
#endif //SESONS;


	//TODO connect FOG_COLOR.rgb (available here 100%) and TIME attribute (hope is available) with ownFogColor value
	//to change its color depending on day/night cicle and weater
	if(isWater < 0.1){
		//add blue fog everywhere except water;
		diffuse.rgb = mix(diffuse.rgb, blueFog.rgb, blueFog.a * isDay);// 1.0/1.5 = 0.6666667
	}

	//TODO user actual position instead of relativePosition;	
	diffuse.rgb = mix(diffuse.rgb, milkyFog.rgb, milkyFog.a * isRain * 1.3);
#ifdef FOG
//we dont have realativePosityon here, so it brakes everything
	//fogColor.rgb = vec3(0.1,0.3,1.0);
	//fogColor.a -= relativePosityon.y;
	//fogColor.rgb = FOG_COLOR.rgb;
	diffuse.rgb = mix( diffuse.rgb, fogColor.rgb * vec3(0.5, 0.75, 1.0) * 4.0, fogColor.a);

#endif //FOG

	///////////////////color correction section////////////////////
/*
	vec4 colorCorrectionContrast = vec4(1.5, 1.25, 1.0, 1.0);
	vec4 colorCorrectionTint = vec4(1.75,1.5,1.0,1.0);
	float colorCorrectionSaturation = 0.75;
	diffuse.rgb = atan(pow(diffuse.rgb * colorCorrectionTint.rgb, colorCorrectionContrast.rgb));//avoid super bright areas (atan(x) can't be grater then 1.0)
	float grayScaleDiffuse = (diffuse.r + diffuse.g + diffuse.b)/3.0;
	diffuse.rgb = mix(vec3(grayScaleDiffuse), diffuse.rgb, colorCorrectionSaturation);
	
*/


	//experimental color correction
	vec3 tint = vec3(1.5, 1.25, 1.0);
	diffuse.rgb *= tint;

	float contrast = 1.5;
	diffuse.rgb = pow(diffuse.rgb, vec3(contrast));

	//tone compensation
	diffuse.rgb = diffuse.rgb/(diffuse.rgb + vec3(1.0));
	//gamma correction
	float gamma = 0.999;
	diffuse.rgb = pow(diffuse.rgb, vec3(1.0 / gamma));

	float saturation = 0.999;
	float grayScale = (diffuse.r + diffuse.g + diffuse.b) / 3.0;
	diffuse.rgb = mix(vec3(grayScale), diffuse.rgb, saturation);


	///////////////////////debuging section//////////////////////

	//debug texture coordinates
	//diffuse.rgb *= vec3(fract(uv0.x*32.0), fract(uv0.y*32.0), 1.0);

	//debug all lighting 
	//diffuse.rgb = sunLightColor * sunDot;
	//diffuse.rgb = mix(diffuse.rgb, perPixelFresnel.rgb, perPixelFresnel.a);
	//diffuse.rgb = mix(diffuse.rgb, perPixelSpecular.rgb, perPixelSpecular.a);
	//diffuse.rgb /= 2.0;

	//debug only reflective components
	//diffuse.rgb = mix(vec3(0.0), perPixelFresnel.rgb, perPixelFresnel.a);
	//diffuse.rgb = mix(diffuse.rgb, perPixelSpecular.rgb, perPixelSpecular.a);

	
	//diffuse.rgb = mix(vec3(0.1), perPixelSpecular.rgb, perPixelSpecular.a);


	//diffuse.rgb = mix(vec3(0.0), vec3(1.0), fract(time / 1000.0 + 0.5));

	//debug normals
	//diffuse.rgb = normalColor.rgb;

	//debug normalsOffset
	//diffuse.rg = localNormalCoord * 64.0;
	//diffuse.b = 0.0;
	//diffuse.a = 1.0;


	//dbug position
	//diffuse.rgb = sin(position.xyz/2.545) * 0.5 + 0.5;
	
	//debug inColor
	//diffuse = color;
//	if(color.r > 0.59 && color.b > 0.99 && color.g > 0.11){
//		diffuse = color;
//	}

	//debug fog
	//diffuse.rgb = mix(vec3(0.0), blueFog.rgb, blueFog.a);
	//diffuse.rgb = mix(diffuse.rgb, milkyFog.rgb, milkyFog.a);
	//diffuse.rgb = mix(vec3(0.0), fogColor.rgb, fogColor.a);
   
   	//debug daytime and weather
	//diffuse.rgb = vec3(isDay, isSunrise, isNight);
//	diffuse.rgb = vec3(isDay);
   	//diffuse.rgb = vec3(isNight);
	//diffuse.rgb = vec3(isRain);


	//diffuse.rgb = texture2D(TEXTURE_1, vec2(0.0,1.0)).rgb;
	//diffuse.rgb = pow(diffuse.rgb, vec3(8.0));
	//diffuse.rgb *= 1.1001;
	//if(diffuse.b > 1.0){
	//    diffuse.rgb = vec3(1.0, 0.0, 0.0);
	//}

	//diffuse.rgb = vec3(isRain, isDay, 1.0 - isDay);
	

	gl_FragColor = diffuse;
	//check if vim broke this file (looks like it happens sometimes :-/)
	//gl_FragColor = vec4(1.0,0.0,0.0,1.0);
#endif // BYPASS_PIXEL_SHADER
}
