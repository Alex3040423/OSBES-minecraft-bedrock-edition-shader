// __multiversion__
// This signals the loading code to prepend either #version 100 or #version 300 ES as appropriate.
//#extension GL_EXT_shader_framebuffer_fetch : require

#include "fragmentVersionCentroid.h"

#include "includes/color_grading.glsl"
#include "includes/helpers.glsl"
#include "includes/ingame_env.glsl"
#include "includes/lighting.glsl"
#include "includes/clouds.glsl"
#include "includes/texture_mapping.glsl"

#if __VERSION__ >= 300
	#ifndef BYPASS_PIXEL_SHADER
		// #if defined(TEXEL_AA) && defined(TEXEL_AA_FEATURE)
		// 	_centroid in highp vec2 uv0;
		// 	_centroid in highp vec2 uv1;
		// #else
			_centroid in highp vec2 uv0;
			_centroid in highp vec2 uv1;
		// #endif
	#endif //BYPASS_PIXEL_SHADER
#else
	#ifndef BYPASS_PIXEL_SHADER
		varying vec2 uv0;
		varying vec2 uv1;
	#endif	//BYPASS_PIXEL_SHADER
#endif //VERSION


varying float isRain;

varying float isWater;
varying float isUnderWater;
varying vec4 color;
vec4 normalColor;// Fake normal vector will be stored here or may be later will be passed from vertex shader
varying highp vec4 position;// Get pixel position in world space (used for calculate fake normals)
varying highp vec4 relativePosition;// Calculates from vec4 position
//#ifdef FOG
	varying vec4 fogColor;
//#endif //FOG

#include "uniformShaderConstants.h"
#include "util.h"
#include "uniformPerFrameConstants.h"
LAYOUT_BINDING(0) uniform sampler2D TEXTURE_0;
LAYOUT_BINDING(1) uniform sampler2D TEXTURE_1;
LAYOUT_BINDING(2) uniform sampler2D TEXTURE_2;

varying vec4 blueFog;
varying vec4 milkyFog;


void main()
{
    float isDay = detectDay(TEXTURE_1);
    float isSunrize = detectSunrize(FOG_COLOR.rgb);
    float isHell = detectHell(TEXTURE_1);

#ifdef BYPASS_PIXEL_SHADER
	gl_FragColor = vec4(1.0, 0, 0, 1.0);
	return;
#else 

/*#if USE_TEXEL_AA
	vec4 diffuse = texture2D_AA(TEXTURE_0,uv0);
#else*/


	////////////////////////////Mapping section///////////////////////////////////	
	// Top left texture - default diffuse
	highp vec2 localDiffuseCoord = fract(uv0 * vec2(32.0)) * vec2(0.015625);// 1.0 / 64.0 = 0.015625
	vec4 diffuse = texelFetch(TEXTURE_0, ivec2((uv0 - localDiffuseCoord) * 1024.0), 0);
	// Top right texture - specular map
	highp vec2 localSpecularCoord = localDiffuseCoord - vec2(0.015625, 0.0);// 1.0/64.0 = 0.015625
	vec4 specularMap = clamp(texelFetch(TEXTURE_0, ivec2((uv0 - localSpecularCoord) * 1024.0), 0),0.01, 1.0);
	
	vec4 normalMap = vec4(0.0);	
	normalColor.rgb = vec3(0.0);
	
	vec4  puddles = vec4(0.0);

	if(isRain > 0.1 && isWater < 0.1){
		
		puddles.rgb = calculatePuddles(TEXTURE_0, position.xz, isRain, uv1.y);
		
	}

	if(isWater >  0.9){
		normalMap.rgb = calculateWaterNormal(TEXTURE_0, position.xz);
	}else{
		// Bottom left texture - normalmap
		highp vec2 localNormalCoord = localDiffuseCoord - vec2(0.0, 0.015625);
		normalMap = texelFetch(TEXTURE_0, ivec2((uv0 - localNormalCoord) * 1024.0), 0);
	}
	
//#endif //USE_TEXEL_AA


// Maybe it's about LOD (far trees and water becomes opaque)
#ifdef SEASONS_FAR
	diffuse.a = 1.0;
#endif //SEASONS_FAR


#if USE_ALPHA_TEST
	#ifdef ALPHA_TO_COVERAGE
	#define ALPHA_THRESHOLD 0.05
	#else
	#define ALPHA_THRESHOLD 0.5
	#endif //APLPHA_TO_COVERAGE
	if(diffuse.a < ALPHA_THRESHOLD)
		discard;// Cutout leaves and grass
#endif //USE_ALPHA_TEST
	

#if defined(BLEND)
	//diffuse.a *= inColor.a;
#endif //BLEND

#if !defined(ALWAYS_LIT)
	
	////////////////////////////Normal maps and lighting section////////////////////////////////




	highp vec3 dp1 = dFdx(position.xyz);
	highp vec3 dp2 = dFdy(position.xyz);

	vec3 initNormalColor = normalize(cross(dp1, dp2));
	normalColor.rgb = initNormalColor;

	normalColor.rgb = rotateNormalMap(normalMap.rgb, normalColor.rgb);
	// normalColor.rgb = rotateNormalMap(normalMap.rgb, normalColor.rgb, uv0, dp1, dp2);
	// normalColor.rgb = rotateNormalMap(initNormalColor.rgb, normalColor.rgb, normalMap.rgb, position.xyz, uv0);
	



	// Water, grass and leaves color
	diffuse.rgb *= color.rgb;

	// Dark puddles color (affected by fresnel later)
	puddles.r = max(initNormalColor.g * puddles.r, 0.5);
	diffuse.rgb = mix(diffuse.rgb, vec3(0.15,0.15,0.15),puddles.r * isRain);

	


	///////////////////////Lighting section//////////////////////////

	const vec3 skyLightDirection  = vec3(0.0,1.0,0.0);
	const float skyLightWrapping = 4.0;
	float skyDot = max((dot(skyLightDirection, normalColor.rgb) + skyLightWrapping)/(1.0 + skyLightWrapping),0.0);
	
	vec3 rainSkyLightColor = vec3(0.5, 0.5, 0.5) * isRain * isDay;
	vec3 clearSkyLightColor = pow(FOG_COLOR.rgb, vec3(1.25)) /** isDay */* (1.0 - isRain); 
	
	if(isHell > 0.9){
		clearSkyLightColor = vec3(0.0);
		rainSkyLightColor = vec3(0.0);
	}


	
	vec3 skyLightColor = rainSkyLightColor + clearSkyLightColor;

	const vec3 sunLightDirection = vec3(0.55,0.4,0.05);
	float sunDot = max(dot(sunLightDirection, normalColor.rgb), 0.0);	
	const vec3 sunLightColor = vec3(1.0, 0.88, 0.69);
	const vec3 moonLightColor = vec3(0.35, 0.6,1.0) * 0.35;
	
	
	// Blinn-phong
	highp vec3 debugLightDir = vec3(0.975, 0.025, 0.0);
	highp vec3 viewDir = normalize(relativePosition.xyz);
	highp vec3 halfwayDir = normalize(debugLightDir + viewDir); 
//	halfwayDir = clamp(halfwayDir, 0.0, 1.0);
	highp float shininess = 32.0 * pow(specularMap.r, 2.0)  + 1024.0 * isWater;
	highp float spec = pow(max(dot(normalColor.rgb, halfwayDir), 0.0), shininess) * (1.0 - isRain);
	

	// Phong (fake halo effect)
	float haloPhongIntecity = 0.06 * isSunrize;
	vec3 reflectDir = reflect(-debugLightDir, normalColor.rgb);
	float haloPhong = pow(max(dot(viewDir, reflectDir), 0.0), 8.0) * haloPhongIntecity;

	// The same for onther light source (sunrize, sunset)
	highp vec3 reverseDebugLightDir = vec3(-0.975, 0.025, 0.0);
	reflectDir = reflect(-reverseDebugLightDir, normalColor.rgb);
	float secondHaloPhong = pow(max(dot(viewDir, reflectDir), 0.0), 8.0) * haloPhongIntecity;

	spec += haloPhong + secondHaloPhong;

	vec4 sunLightSpecular = vec4(sunLightColor, spec * specularMap.r * (isDay - isRain));
	vec4 moonLightSpecular = vec4(moonLightColor, spec * specularMap.r * ((1.0 - isDay) - isRain));



	vec4 pointLights = vec4(1.0);
	pointLights.rgb = calculatePointLights(uv1.x);


	vec4 ambientOclusion = vec4(uv1.y + isHell* 0.5);
	vec4 fakeShadow = clamp(pow(ambientOclusion * 1.15, vec4(128.0)),0.0,1.0);
	vec4 fakeMoonShadow = clamp(pow(ambientOclusion * 1.15, vec4(64.0)), 0.0, 1.0);


	if(isUnderWater > 0.9){
        fakeShadow += calculateCaustics(TEXTURE_0, position.xyz);
	}
	
	

	spec = pow(max(dot(normalColor.rgb, viewDir), 0.0), shininess * 0.25);
	vec4 pointLightsSpec = vec4(pow(min(pointLights.rgb * 3.0, 1.0), vec3(2.0)), spec * specularMap.r * pointLights.r * max((2.0 - (isDay + fakeShadow)), 0.0));
	
	

	// Fake effect when surface is hit at a very small angle and light bounces from the surface 
	const float fresnelFactor = 4.0;
	float fresnel = min(pow(1.0 - dot(normalColor.rgb, viewDir), fresnelFactor), 1.0);

	
	float farWaterFresnel = min(pow(1.0 - dot(initNormalColor.rgb, viewDir), fresnelFactor), 1.0);
	fresnel = mix(fresnel, 1.0, farWaterFresnel * isWater);
	

	// The same tweak but with puddles
	float puddlesFresnel = pow(1.0 - dot(initNormalColor.rgb, viewDir), fresnelFactor * 0.5 );	
	fresnel = mix(fresnel, puddlesFresnel, puddles.r * isRain * initNormalColor.g * (1.0 - isWater));
	


	vec4 pointLightsFresnel = vec4(pointLights.rgb, fresnel * (2.0 - (isDay + fakeShadow)));


	// Mix lighting
	vec3 resultLighting = ambientOclusion.rgb * skyLightColor * skyDot * 0.5;	
	vec4 skyLightFresnel = vec4(resultLighting, fresnel * (clamp(0.25 + (specularMap.r * 0.75) + isRain * puddles.r, 0.0, 1.0)));

	resultLighting += pointLights.rgb;
	resultLighting += sunLightColor * sunDot * fakeShadow.r * isDay * (1.0 - isRain);
	resultLighting += vec3(isHell * 0.175);// Ambient highlighting in hell
	resultLighting += moonLightColor * sunDot * fakeMoonShadow.r * (1.0 - isDay) * (1.0 - isRain );
	
	diffuse.rgb *= resultLighting.rgb * 1.8; 
	diffuse.rgb = mix(diffuse.rgb, skyLightFresnel.rgb, skyLightFresnel.a);
	diffuse.rgb = mix(diffuse.rgb, sunLightSpecular.rgb, sunLightSpecular.a * fakeShadow.r);
	diffuse.rgb = mix(diffuse.rgb, moonLightSpecular.rgb, moonLightSpecular.a * fakeShadow.r);
#endif //ALWAYS_LIT


// Water
#ifndef SEASONS
	#if !USE_ALPHA_TEST && !defined(BLEND)
		//diffuse.a = inColor.a;//with this parameter we can detirmane if it's water or leaves 
	#endif //USE_ALPHA_TEST
		//TODO: Move to default pipeline with default fog and sun colors
		//diffuse.rgb *= color.rgb;
		if(isWater > 0.9){
		    highp float time = TIME;
	        highp float cloudsSpeed = 0.1;
	        highp float cloudsScale = 1.0;
	        int cloudsDetail = 0;
			

			highp vec2 cldCoord = -relativePosition.xz;
			cldCoord += normalColor.rb * 2.0;
			cldCoord /= 1.0 + pow(skyLightFresnel.a, 4.0);
			cldCoord /= length(relativePosition.y);
			
			float clouds = calculateCloudsBase(cldCoord, cloudsSpeed, cloudsScale, cloudsDetail);

			//float cloudsShadow = pow(clamp(clouds * 1.25, 0.0, 1.0), 4.0);

			clouds = pow(clamp(clouds * 1.75, 0.0, 1.0), mix(128.0, 2.0, isRain));

		    
			vec3 clearSkyCloudsColor = vec3(0.6, 0.75, 0.9) * pow(FOG_COLOR.b, 2.0);
			vec3 rainSkyCloudsColor = vec3(0.6, 0.75, 0.9) * pow(FOG_COLOR.b, 2.0) * 2.0;
			
			vec3 cloudsColor = mix(clearSkyCloudsColor, rainSkyCloudsColor, isRain);

		    
		    
		    
			diffuse.rgb = mix(diffuse.rgb * 0.125 + length(clearSkyLightColor) * vec3(0.05, 0.1, 0.2), skyLightFresnel.rgb * 1.25, pow(skyLightFresnel.a, 2.0));

			diffuse.rgb = mix(diffuse.rgb, cloudsColor, clouds * (0.25 + skyLightFresnel.a * 0.75));
			//diffuse.rgb = mix(diffuse.rgb, vec3(0.6, 0.8, 1.0) * 0.5, cloudsShadow * (0.01 + pow(skyLightFresnel.a, 1.5) * 0.99));

			diffuse.rgb = mix(diffuse.rgb, fakeShadow.rgb * sunLightColor * 20.0 * isDay, sunLightSpecular.a);
			diffuse.rgb = mix(diffuse.rgb, fakeShadow.rgb * moonLightColor * 1.5 * (1.0 - isDay), moonLightSpecular.a);

			diffuse.rgb += pointLightsFresnel.rgb * pointLightsFresnel.a;
			diffuse.rgb +=  pointLightsSpec.rgb * pointLightsSpec.a;

			diffuse.a = skyLightFresnel.a + sunLightSpecular.a +  moonLightSpecular.a + pointLightsSpec.a;
			diffuse.a = min(diffuse.a + 0.5, 1.0);
			//diffuse.a = 1.0;
		}

#else

	//vec2 uv = inColor.xy;
	//diffuse.rgb *= mix(vec3(1.0,1.0,1.0), texture2D( TEXTURE_2, uv).rgb*2.0, inColor.b);
	//diffuse.rgb *= inColor.aaa;
	//diffuse.a = 1.0;
#endif //SEASONS;


	//TODO: connect FOG_COLOR.rgb (available here 100%) and TIME attribute (hope it's available) with ownFogColor value
	//to change its color depending on day/night cicle and weater
	//Add blue fog everywhere when weather is good except water and hell
	diffuse.rgb = mix(diffuse.rgb, blueFog.rgb, blueFog.a * pow(isDay, 2.0) * (1.0 - isWater) * (1.0 - isRain) * (1.0 - isHell));// 1.0/1.5 = 0.6666667
	
	//TODO: user actual position instead of relativePosition
	vec3 milkyFogColor = mix(vec3(0.1), milkyFog.rgb, isDay);
	diffuse.rgb = mix(diffuse.rgb, milkyFogColor, milkyFog.a * (1.0 - isHell));
#ifdef FOG
	//diffuse.rgb = mix( diffuse.rgb, fogColor.rgb * vec3(0.5, 0.75, 1.0), fogColor.a);
	diffuse.rgb = mix( diffuse.rgb, clearSkyLightColor + rainSkyLightColor * 0.3, fogColor.a);
#endif //FOG


    diffuse = colorGrading(diffuse);


	// Default fog in hell because it has no skyplane
	if(isHell > 0.9){
		diffuse.rgb = mix( diffuse.rgb, FOG_COLOR.rgb, fogColor.a);
	}

	///////////////////////Debuging section//////////////////////

	// Debug texture coordinates
	//diffuse.rgb *= vec3(fract(uv0.x*32.0), fract(uv0.y*32.0), 1.0);

	// Debug all lighting 
	//diffuse.rgb = sunLightColor * sunDot;
	//diffuse.rgb = mix(diffuse.rgb, perPixelFresnel.rgb, perPixelFresnel.a);
	//diffuse.rgb = mix(diffuse.rgb, perPixelSpecular.rgb, perPixelSpecular.a);
	//diffuse.rgb /= 2.0;

	// Debug only reflective components
	//diffuse.rgb = mix(vec3(0.0), skyLightFresnel.rgb, skyLightFresnel.a);
	//diffuse.rgb = mix(diffuse.rgb, perPixelSpecular.rgb, perPixelSpecular.a);
	
	//diffuse.rgb = mix(vec3(0.1), perPixelSpecular.rgb, perPixelSpecular.a);

	// Debug normals
	//diffuse.rgb = (normalColor.rgb + 1.0) * 0.5;

	// Debug normalsOffsets
	//diffuse.rg = localNormalCoord * 64.0;
	//diffuse.b = 0.0;
	//diffuse.a = 1.0;


	// Debug position
	//diffuse.rgb = sin(position.xyz/2.545) * 0.5 + 0.5;
	
	// Debug inColor
	//diffuse = color;
	//if(color.r > 0.59 && color.b > 0.99 && color.g > 0.11){
	//	diffuse = color;
	//}

	// Debug fog
	//diffuse.rgb = mix(vec3(0.0), blueFog.rgb, blueFog.a);
	//diffuse.rgb = mix(diffuse.rgb, milkyFog.rgb, milkyFog.a);
	//diffuse.rgb = mix(vec3(0.0), fogColor.rgb, fogColor.a);
   
    // Debug daytime and weather
	//diffuse.rgb = vec3(isDay, isSunrise, isNight);
    //diffuse.r = isHell;
    //diffuse.g = isDay;
	//diffuse.b = isRain;

    // Debug tile texture
	// diffuse = texelFetch(TEXTURE_0, ivec2(position.xz * 128.0), 0);

	
	
	//vec3 sphereNormal = (normalize(position.xyz) + 1.0) / 2.0;
	//diffuse.rgb = sphereNormal;

	//diffuse.rgb = texelFetch(TEXTURE_1, ivec2(position.xz * 4.0),0).rgb;
	//diffuse.rgb = texture2D(TEXTURE_1, vec2(0.0, 1.0)).rgb;
	
	gl_FragColor = diffuse;
#endif // BYPASS_PIXEL_SHADER
}
