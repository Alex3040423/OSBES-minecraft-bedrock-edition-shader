// __multiversion__
// This signals the loading code to prepend either #version 100 or #version 300 ES as appropriate.
//#extension GL_EXT_shader_framebuffer_fetch : require

#include "fragmentVersionCentroid.h"

#if __VERSION__ >= 300
	#ifndef BYPASS_PIXEL_SHADER
		#if defined(TEXEL_AA) && defined(TEXEL_AA_FEATURE)
			_centroid in highp vec2 uv0;
			_centroid in highp vec2 uv1;
		#else
			_centroid in highp vec2 uv0;
			_centroid in highp vec2 uv1;
		#endif
	#endif //BYPASS_PIXEL_SHADER
#else
	#ifndef BYPASS_PIXEL_SHADER
		varying vec2 uv0;
		varying vec2 uv1;
	#endif	//BYPASS_PIXEL_SHADER
#endif //VERSION


varying float isRain;

varying float isWater;
varying float isUnderWater;
varying vec4 color;
varying highp vec4 position;// Get pixel position in world space (used for calculate fake normals)
varying highp vec4 relativePosition;// Calculates from vec4 position
//#ifdef FOG
	varying vec4 fogColor;
//#endif //FOG

#include "uniformShaderConstants.h"
#include "util.h"
#include "uniformPerFrameConstants.h"
#include "includes/env_detectors.glsl"
#include "includes/texture_mapping.glsl"
#include "includes/random.glsl"
#include "includes/color_correction.glsl"
#include "includes/reflections.glsl"
#include "includes/lighting.glsl"
#include "includes/helpers.glsl"


LAYOUT_BINDING(0) uniform sampler2D TEXTURE_0;
LAYOUT_BINDING(1) uniform sampler2D TEXTURE_1;
LAYOUT_BINDING(2) uniform sampler2D TEXTURE_2;

varying vec4 blueFog;
varying vec4 milkyFog;



void main()
{
#ifdef BYPASS_PIXEL_SHADER
	gl_FragColor = vec4(1.0, 0, 0, 1.0);
	return;
#else 

/*#if USE_TEXEL_AA
	vec4 diffuse = texture2D_AA(TEXTURE_0,uv0);
#else*/

	float isDay = detectDay(TEXTURE_1);
   	float isHell = detectHell(TEXTURE_1);
	float isSunrize = detectSunRize();

	highp vec3 initialNormalVector = calculateRawNormalVector(position.xyz);
	highp vec3 normalVector = initialNormalVector;	

	vec4 diffuseMap = vec4(0.0);
	vec3 reliefMap = vec3(0.0);
	vec4 rmeMap = vec4(0.0);

	readTextures(diffuseMap, reliefMap, rmeMap, TEXTURE_0, uv0);

	vec4 diffuse = diffuseMap;
	
	float  wetness = 0.0;
	if(isRain > 0.1 && isWater < 0.1){
		wetness = mapPuddles(TEXTURE_0, position.xz, isRain);	
		wetness = max(initialNormalVector.g * wetness, 0.5);		
	}

	highp float metalness = mix(pow(rmeMap.g, 4.0), 0.0, wetness);
	highp float roughness = mix(pow(rmeMap.r, 4.0), 1.0, wetness);
	highp float shininess = 512.0 * roughness;

	float srcPointLights = uv1.x;
	float ambientOclusion = uv1.y + isHell * 0.5;

#if defined(BLEND)
	if(isWater >  0.9){
		reliefMap = mapWaterNormals(TEXTURE_0);
		metalness = 0.0;
		roughness = 1.0;
		diffuse.rgb *= 0.5;
	}
#endif
	
//#endif //USE_TEXEL_AA

// Maybe it's about LOD (far trees and water becomes opaque)
#ifdef SEASONS_FAR
	diffuse.a = 1.0;
#endif //SEASONS_FAR


#if USE_ALPHA_TEST
	#ifdef ALPHA_TO_COVERAGE
	#define ALPHA_THRESHOLD 0.05
	#else
	#define ALPHA_THRESHOLD 0.5
	#endif //APLPHA_TO_COVERAGE
	if(diffuse.a < ALPHA_THRESHOLD)
		discard;// Cutout leaves and grass
#endif //USE_ALPHA_TEST
	

#if !defined(ALWAYS_LIT)

	//water, grass and leaves color
	diffuse.rgb *= color.rgb;
	// Dark wetness color (affected by detailedFresnel later)
	diffuse.rgb = mix(diffuse.rgb, vec3(0.25,0.25,0.25), wetness * isRain);
	

	normalVector = rotateNormals(normalVector, reliefMap);

	highp vec3 viewDir = normalize(relativePosition.xyz);
	
	
	///////////////////////Lighting section//////////////////////////

	vec4 skyLightDiffused = calculateSkyLightDiffused(normalVector, isRain, isDay, isHell);

	vec4 mainLightDiffused = calculateMainLightDiffused(normalVector, isDay);

	// Torches, lamps and lava lights
	vec3 pointLightsDiffused = calculatePointLightsDiffused(srcPointLights);
	
	vec4 mainLightReflected = calculateMainLightsReflection(normalVector, viewDir, mainLightDiffused, shininess, isRain, isSunrize);



	float fakeShadow = clamp(pow(ambientOclusion * 1.15, 128.0),0.0,1.0);

	if(isUnderWater > 0.9){
		fakeShadow += mapCaustics(TEXTURE_0, position.xyz);
	}


	vec4 pointLightsReflected = calculatePointLightsReflected(normalVector, viewDir, shininess, pointLightsDiffused);
	

	// Fake effect when surface is hit at a very small angle and light bounces from the surface 
	float flatFresnel = min(1.0 - dot(initialNormalVector, viewDir), 1.0);
	float detailedFresnel = min(1.0 - dot(normalVector, viewDir), 1.0);

	detailedFresnel = pow(detailedFresnel, 6.0);
	flatFresnel = pow(flatFresnel, 3.0);

	detailedFresnel = mix(detailedFresnel, flatFresnel, isWater);
	detailedFresnel = mix(detailedFresnel, flatFresnel, wetness * isRain * initialNormalVector.g * (1.0 - isWater));


	// Mix lighting
	vec3 resultLighting = skyLightDiffused.rgb * skyLightDiffused.a * ambientOclusion * 0.5;	
	vec4 skyLightReflected = vec4(resultLighting * 2.0, detailedFresnel * (clamp(0.25 + (rmeMap.r * 0.75) + isRain * wetness, 0.0, 1.0)));

	resultLighting += pointLightsDiffused;
	resultLighting += mainLightDiffused.rgb * mainLightDiffused.a * fakeShadow * (1.0 - isRain);
	resultLighting += vec3(isHell * 0.175);// Ambient highlighting in hell
	
	diffuse.rgb *= resultLighting.rgb * 1.8 * (1.0 - metalness); 

	
	vec3 reflection = buildSkyPlaneReflection(relativePosition.xyz, normalVector, skyLightReflected, isRain, roughness) * 1.0;

    reflection += mainLightReflected.rgb * mainLightReflected.a * fakeShadow * 4.0;
	reflection += pointLightsReflected.rgb * pointLightsReflected.a * 10.0;
	vec3 metalnessReflection = diffuseMap.rgb * reflection * metalness;
	vec3 insulatorsReflection = reflection * (1.0 - metalness) * roughness;
	vec3 resultReflections = metalnessReflection + insulatorsReflection;

	float f0 = metalness * 0.5 + (1.0 - metalness) * 0.05;
	float f1 = 1.0;
	
	
	diffuse.rgb = mix(diffuse.rgb, resultReflections, f0 + skyLightReflected.a * f1);

	diffuse.a = max(diffuse.a, skyLightReflected.a + mainLightReflected.a + pointLightsReflected.a);	
	
	// diffuse.rgb = vec3(1.0, 0.0, 0.0);	
#endif //ALWAYS_LIT


#if defined(BLEND)

#endif //BLEND

	//Add blue fog everywhere when weather is good except water and hell
	diffuse.rgb = mix(diffuse.rgb, blueFog.rgb, blueFog.a * pow(isDay, 2.0) * (1.0 - isWater) * (1.0 - isRain) * (1.0 - isHell));// 1.0/1.5 = 0.6666667
	
	//TODO: user actual position instead of relativePosition
	vec3 milkyFogColor = mix(vec3(0.1), milkyFog.rgb, isDay);
	diffuse.rgb = mix(diffuse.rgb, milkyFogColor, milkyFog.a * (1.0 - isHell));
// #ifdef FOG
	diffuse.rgb = mix( diffuse.rgb, skyLightDiffused.rgb, fogColor.a);
// #endif //FOG

	diffuse.rgb = colorCorrection(diffuse.rgb);

	// Default fog in hell because it has no skyplane
	if(isHell > 0.9){
		diffuse.rgb = mix( diffuse.rgb, FOG_COLOR.rgb, fogColor.a);
	}

	///////////////////////Debuging section//////////////////////

	// Debug texture coordinates
	//diffuse.rgb *= vec3(fract(uv0.x*32.0), fract(uv0.y*32.0), 1.0);

	
	// Debug position
	//diffuse.rgb = sin(position.xyz/2.545) * 0.5 + 0.5;

    // Debug tile texture
	// diffuse = texelFetch(TEXTURE_0, ivec2(position.xz * 128.0), 0);

	//vec3 sphereNormal = (normalize(position.xyz) + 1.0) / 2.0;
	//diffuse.rgb = sphereNormal;

	//diffuse.rgb = texelFetch(TEXTURE_1, ivec2(position.xz * 4.0),0).rgb;
	//diffuse.rgb = texture2D(TEXTURE_1, vec2(0.0, 1.0)).rgb;
	
	gl_FragColor = diffuse;
#endif // BYPASS_PIXEL_SHADER
}
